import time
import random
import requests
from PIL import Image, ImageDraw, ImageFont
import os
import json

# === CONFIGURATION ===

# Set Facebook Page ID, Access Token
PAGE_ID = os.getenv("FB_PAGE_ID")
ACCESS_TOKEN = os.getenv("FB_ACCESS_TOKEN")

import os
BASE_DIR = os.path.dirname(os.path.abspath(__file__))

# Background images
QURAN_BG_DIR = os.path.join(BASE_DIR, "assets", "quranbg")
HADITH_BG_DIR = os.path.join(BASE_DIR, "assets", "hadithbg")
QA_BG_DIR = os.path.join(BASE_DIR, "assets", "qabg")

# fonts
HADITH_FILE = os.path.join(BASE_DIR, "data", "hadiths_bn_fixed.json")
POSTED_TRACKER_FILE = os.path.join(BASE_DIR, "data", "hadith_posted_tracker.json")

FONT_AYAH = os.path.join(BASE_DIR, "assets", "fonts", "Tinos-Bold.ttf")
FONT_FOOTER = os.path.join(BASE_DIR, "assets", "fonts", "Tinos-Bold.ttf")
FONT_ARABIC = os.path.join(BASE_DIR, "assets", "fonts", "Tinos-Bold.ttf")


# === Telegram Config ===
telegram_token = os.getenv("TELEGRAM_BOT_TOKEN")  # Replace with your actual bot token
telegram_chat_id = os.getenv("TELEGRAM_CHAT_ID")  # Replace with your actual channel username or chat ID

# Create Hadith tracker file to prevent reposting the same hadith

if not os.path.exists(POSTED_TRACKER_FILE):
    with open(POSTED_TRACKER_FILE, "w", encoding="utf-8") as f:
        json.dump([], f)

with open(HADITH_FILE, "r", encoding="utf-8") as f:
    all_hadiths = json.load(f)

english_surah_names = {
    1: "Al-Fatiha", 2: "Al-Baqara", 3: "Aal-E-Imran", 4: "An-Nisa", 5: "Al-Ma'idah", 6: "Al-An'am",
    7: "Al-A'raf", 8: "Al-Anfal", 9: "At-Tawbah", 10: "Yunus", 11: "Hud", 12: "Yusuf",
    13: "Ar-Ra'd", 14: "Ibrahim", 15: "Al-Hijr", 16: "An-Nahl", 17: "Al-Isra", 18: "Al-Kahf",
    19: "Maryam", 20: "Taha", 21: "Al-Anbiya", 22: "Al-Hajj", 23: "Al-MuтАЩminun", 24: "An-Nur",
    25: "Al-Furqan", 26: "Ash-ShuтАЩara", 27: "An-Naml", 28: "Al-Qasas", 29: "Al-Ankabut",
    30: "Ar-Rum", 31: "Luqman", 32: "As-Sajda", 33: "Al-Ahzab", 34: "Saba", 35: "Fatir",
    36: "Ya-Sin", 37: "As-Saffat", 38: "Sad", 39: "Az-Zumar", 40: "Ghafir", 41: "Fussilat",
    42: "Ash-Shura", 43: "Az-Zukhruf", 44: "Ad-Dukhan", 45: "Al-Jathiya", 46: "Al-Ahqaf",
    47: "Muhammad", 48: "Al-Fath", 49: "Al-Hujurat", 50: "Qaf", 51: "Adh-Dhariyat",
    52: "At-Tur", 53: "An-Najm", 54: "Al-Qamar", 55: "Ar-Rahman", 56: "Al-Waqi'a",
    57: "Al-Hadid", 58: "Al-Mujadila", 59: "Al-Hashr", 60: "Al-Mumtahanah",
    61: "As-Saff", 62: "Al-JumuтАЩa", 63: "Al-Munafiqoon", 64: "At-Taghabun",
    65: "At-Talaq", 66: "At-Tahrim", 67: "Al-Mulk", 68: "Al-Qalam", 69: "Al-Haqqah",
    70: "Al-Ma'arij", 71: "Nuh", 72: "Al-Jinn", 73: "Al-Muzzammil", 74: "Al-Muddaththir",
    75: "Al-Qiyamah", 76: "Al-Insan", 77: "Al-Mursalat", 78: "An-Naba", 79: "An-Nazi'at",
    80: "Abasa", 81: "At-Takwir", 82: "Al-Infitar", 83: "Al-Mutaffifin", 84: "Al-Inshiqaq",
    85: "Al-Buruj", 86: "At-Tariq", 87: "Al-Ala", 88: "Al-Ghashiyah", 89: "Al-Fajr",
    90: "Al-Balad", 91: "Ash-Shams", 92: "Al-Lail", 93: "Ad-Duhaa", 94: "Ash-Sharh",
    95: "At-Tin", 96: "Al-Alaq", 97: "Al-Qadr", 98: "Al-Bayyina", 99: "Az-Zalzalah",
    100: "Al-Adiyat", 101: "Al-Qari'a", 102: "At-Takathur", 103: "Al-Asr", 104: "Al-Humazah",
    105: "Al-Fil", 106: "Quraish", 107: "Al-Ma'un", 108: "Al-Kawthar", 109: "Al-Kafiroon",
    110: "An-Nasr", 111: "Al-Masad", 112: "Al-Ikhlas", 113: "Al-Falaq", 114: "An-Nas"
}
surah_ayah_counts = {
    1: 7, 2: 286, 3: 200, 4: 176, 5: 120, 6: 165, 7: 206,
    10: 109, 12: 111, 14: 52, 15: 99, 16: 128, 17: 111,
    18: 110, 19: 98, 20: 135, 21: 112, 23: 118, 24: 64,
    25: 77, 26: 227, 27: 93, 28: 88, 29: 69, 30: 60,
    31: 34, 33: 73, 35: 45, 36: 83, 37: 182, 39: 75,
    40: 85, 41: 54, 42: 53, 43: 89, 44: 59, 45: 37,
    46: 35, 48: 29, 49: 18, 50: 45, 51: 60, 52: 49,
    53: 62, 54: 55, 55: 78, 56: 96, 57: 29, 58: 22,
    59: 24, 60: 13, 61: 14, 62: 11, 63: 11, 64: 18,
    65: 12, 66: 12, 67: 30
}
# Bangla Surah Name Mapping
bangla_surah_names = {
    1: "рж╕рзВрж░рж╛ ржлрж╛рждрж┐рж╣рж╛",
    2: "рж╕рзВрж░рж╛ ржмрж╛ржХрж╛рж░рж╛",
    3: "рж╕рзВрж░рж╛ ржЖрж▓рзЗ ржЗржорж░рж╛ржи",
    4: "рж╕рзВрж░рж╛ ржирж┐рж╕рж╛",
    5: "рж╕рзВрж░рж╛ ржорж╛рзЯрж┐ржжрж╛",
    6: "рж╕рзВрж░рж╛ ржЖржиржЖржо",
    7: "рж╕рзВрж░рж╛ ржЖрж░рж╛ржл",
    8: "рж╕рзВрж░рж╛ ржЖржиржлрж╛рж▓",
    9: "рж╕рзВрж░рж╛ рждрж╛ржУржмрж╛",
    10: "рж╕рзВрж░рж╛ ржЗржЙржирзБрж╕",
    11: "рж╕рзВрж░рж╛ рж╣рзБржж",
    12: "рж╕рзВрж░рж╛ ржЗржЙрж╕рзБржл",
    13: "рж╕рзВрж░рж╛ рж░рж╛ржж",
    14: "рж╕рзВрж░рж╛ ржЗржмрзНрж░рж╛рж╣рзАржо",
    15: "рж╕рзВрж░рж╛ рж╣рж┐ржЬрж░",
    16: "рж╕рзВрж░рж╛ ржирж╛рж╣рж▓",
    17: "рж╕рзВрж░рж╛ ржмржирзА ржЗрж╕рж░рж╛ржЗрж▓",
    18: "рж╕рзВрж░рж╛ ржХрж╛рж╣ржл",
    19: "рж╕рзВрж░рж╛ ржорж╛рж░рж┐рзЯрж╛ржо",
    20: "рж╕рзВрж░рж╛ рждрзНржм-рж╣рж╛",
    21: "рж╕рзВрж░рж╛ ржЖржорзНржмрж┐рзЯрж╛",
    22: "рж╕рзВрж░рж╛ рж╣рж╛ржЬрзНржЬ",
    23: "рж╕рзВрж░рж╛ ржорзБтАЩржорж┐ржирзВржи",
    24: "рж╕рзВрж░рж╛ ржирзВрж░",
    25: "рж╕рзВрж░рж╛ ржлрзБрж░ржХрж╛ржи",
    26: "рж╕рзВрж░рж╛ ржЖрж╢-рж╢рзБржЖрж░рж╛",
    27: "рж╕рзВрж░рж╛ ржиржорж▓",
    28: "рж╕рзВрж░рж╛ ржХрж╛рж╕рж╛рж╕",
    29: "рж╕рзВрж░рж╛ ржЖржиржХрж╛ржмрзБржд",
    30: "рж╕рзВрж░рж╛ рж░рзВржо",
    31: "рж╕рзВрж░рж╛ рж▓рзЛржХржорж╛ржи",
    32: "рж╕рзВрж░рж╛ рж╕рж╛ржЬржжрж╛",
    33: "рж╕рзВрж░рж╛ ржЖрж╣ржпрж╛ржм",
    34: "рж╕рзВрж░рж╛ рж╕рж╛ржмрж╛",
    35: "рж╕рзВрж░рж╛ ржлрж╛рждрж┐рж░",
    36: "рж╕рзВрж░рж╛ ржЗрзЯрж╛рж╕рж┐ржи",
    37: "рж╕рзВрж░рж╛ рж╕рж╛ржлржлрж╛ржд",
    38: "рж╕рзВрж░рж╛ ржЫрзЛрзЯрж╛ржж",
    39: "рж╕рзВрж░рж╛ ржЬрзБржорж╛рж░",
    40: "рж╕рзВрж░рж╛ ржЧрж╛ржлрж┐рж░",
    41: "рж╕рзВрж░рж╛ ржлрзБрж╕рж╕рж┐рж▓рж╛ржд",
    42: "рж╕рзВрж░рж╛ ржЖрж╢-рж╢рзБрж░рж╛",
    43: "рж╕рзВрж░рж╛ ржпрзБржЦрж░рзБржл",
    44: "рж╕рзВрж░рж╛ ржжрзБржЦрж╛ржи",
    45: "рж╕рзВрж░рж╛ ржЬрж╛рж╕рж┐рзЯрж╛",
    46: "рж╕рзВрж░рж╛ ржЖрж╣ржХрж╛ржл",
    47: "рж╕рзВрж░рж╛ ржорзБрж╣рж╛ржорзНржоржж",
    48: "рж╕рзВрж░рж╛ ржлрж╛рждрж╣",
    49: "рж╕рзВрж░рж╛ рж╣рзБржЬрзБрж░рж╛ржд",
    50: "рж╕рзВрж░рж╛ ржХрж╛ржл",
    51: "рж╕рзВрж░рж╛ ржпрж╛рж░рж┐рзЯрж╛ржд",
    52: "рж╕рзВрж░рж╛ рждрзБрж░",
    53: "рж╕рзВрж░рж╛ ржирж╛ржЬржо",
    54: "рж╕рзВрж░рж╛ ржХрзНржмрж╛ржорж╛рж░",
    55: "рж╕рзВрж░рж╛ ржЖрж░ рж░рж╣ржорж╛ржи",
    56: "рж╕рзВрж░рж╛ ржУрзЯрж╛ржХрж┐рзЯрж╛",
    57: "рж╕рзВрж░рж╛ рж╣рж╛ржжрзАржж",
    58: "рж╕рзВрж░рж╛ ржорзБржЬрж╛ржжрж╛рж▓рж╛рж╣",
    59: "рж╕рзВрж░рж╛ рж╣рж╛рж╢рж░",
    60: "рж╕рзВрж░рж╛ ржорзБржорждрж╛рж╣рж┐ржирж╛",
    61: "рж╕рзВрж░рж╛ ржЖрж╕-рж╕рж╛ржл",
    62: "рж╕рзВрж░рж╛ ржЬрзБржорж╛",
    63: "рж╕рзВрж░рж╛ ржорзБржирж╛ржлрж┐ржХрзБржи",
    64: "рж╕рзВрж░рж╛ рждрж╛ржЧрж╛ржмрзБржи",
    65: "рж╕рзВрж░рж╛ рждрж╛рж▓рж╛ржХ",
    66: "рж╕рзВрж░рж╛ рждрж╛рж╣рж░рж┐ржо",
    67: "рж╕рзВрж░рж╛ ржорзБрж▓ржХ",
    68: "рж╕рзВрж░рж╛ ржХрж▓ржо",
    69: "рж╕рзВрж░рж╛ рж╣рж╛ржХрзНржХрж╛рж╣",
    70: "рж╕рзВрж░рж╛ ржорж╛ржЖрж░рж┐ржЬ",
    71: "рж╕рзВрж░рж╛ ржирзВрж╣",
    72: "рж╕рзВрж░рж╛ ржЬрж┐ржи",
    73: "рж╕рзВрж░рж╛ ржорзБржпржпрж╛ржорзНржорж┐рж▓",
    74: "рж╕рзВрж░рж╛ ржорзБржжрзНржжрж╛рж╕рж╕рж┐рж░",
    75: "рж╕рзВрж░рж╛ ржХрзЗрзЯрж╛ржорж╛рж╣",
    76: "рж╕рзВрж░рж╛ ржЗржирж╕рж╛ржи",
    77: "рж╕рзВрж░рж╛ ржорзБрж░рж╕рж╛рж▓рж╛ржд",
    78: "рж╕рзВрж░рж╛ ржЖржи-ржирж╛ржмрж╛",
    79: "рж╕рзВрж░рж╛ ржирж╛ржпрж┐рзЯрж╛ржд",
    80: "рж╕рзВрж░рж╛ ржЖржмрж╛рж╕рж╛",
    81: "рж╕рзВрж░рж╛ рждрж╛ржХржнрзАрж░",
    82: "рж╕рзВрж░рж╛ ржЗржиржлрж┐рждрж╛рж░",
    83: "рж╕рзВрж░рж╛ ржорзБрждрж╛ржлржлрж┐ржлрж┐ржи",
    84: "рж╕рзВрж░рж╛ ржЗржирж╢рж┐ржХрж╛ржХ",
    85: "рж╕рзВрж░рж╛ ржмрзБрж░рзВржЬ",
    86: "рж╕рзВрж░рж╛ рждрж╛рж░рж┐ржХ",
    87: "рж╕рзВрж░рж╛ ржЖтАЩрж▓рж╛",
    88: "рж╕рзВрж░рж╛ ржЧрж╛рж╢рж┐рзЯрж╛рж╣",
    89: "рж╕рзВрж░рж╛ ржлржЬрж░",
    90: "рж╕рзВрж░рж╛ ржмрж╛рж▓рж╛ржж",
    91: "рж╕рзВрж░рж╛ рж╢рж╛ржорж╕",
    92: "рж╕рзВрж░рж╛ рж▓рж╛ржЗрж▓",
    93: "рж╕рзВрж░рж╛ ржжрзБрж╣рж╛",
    94: "рж╕рзВрж░рж╛ ржЗржирж╢рж┐рж░рж╛рж╣",
    95: "рж╕рзВрж░рж╛ рждрзНржмрзАржи",
    96: "рж╕рзВрж░рж╛ ржЖрж▓рж╛ржХ",
    97: "рж╕рзВрж░рж╛ ржХржжрж░",
    98: "рж╕рзВрж░рж╛ ржмрж╛ржЗрзЯрзНржпрж┐ржирж╛",
    99: "рж╕рзВрж░рж╛ ржЬрж┐рж▓ржпрж╛рж▓",
    100: "рж╕рзВрж░рж╛ ржЖржжрж┐рзЯрж╛ржд",
    101: "рж╕рзВрж░рж╛ ржХрзНржмрж╛рж░рж┐рзЯрж╛",
    102: "рж╕рзВрж░рж╛ рждрж╛ржХрж╛рж╕рзБрж░",
    103: "рж╕рзВрж░рж╛ ржЖрж╕рж░",
    104: "рж╕рзВрж░рж╛ рж╣рзБржорж╛ржпрж╛рж╣",
    105: "рж╕рзВрж░рж╛ ржлрзАрж▓",
    106: "рж╕рзВрж░рж╛ ржХрзБрж░рж╛ржЗрж╢",
    107: "рж╕рзВрж░рж╛ ржорж╛ржЙржи",
    108: "рж╕рзВрж░рж╛ ржХрж╛ржУрж╕рж╛рж░",
    109: "рж╕рзВрж░рж╛ ржХрж╛ржлрж┐рж░рзБржи",
    110: "рж╕рзВрж░рж╛ ржирж╛рж╕рж░",
    111: "рж╕рзВрж░рж╛ рж▓рж╛рж╣рж╛ржм",
    112: "рж╕рзВрж░рж╛ ржЗржЦрж▓рж╛рж╕",
    113: "рж╕рзВрж░рж╛ ржлрж╛рж▓рж╛ржХ",
    114: "рж╕рзВрж░рж╛ ржирж╛рж╕"
}

import os

def share_to_telegram(caption, media_path, telegram_token, telegram_chat_id):
    try:
        url = None
        files = {}
        if media_path.lower().endswith((".jpg", ".jpeg", ".png")):
            url = f"https://api.telegram.org/bot{telegram_token}/sendPhoto"
            files = {'photo': open(media_path, 'rb')}
            data = {'chat_id': telegram_chat_id, 'caption': caption}
        elif media_path.lower().endswith((".mp4", ".mov", ".avi", ".mkv")):
            url = f"https://api.telegram.org/bot{telegram_token}/sendVideo"
            files = {'video': open(media_path, 'rb')}
            data = {'chat_id': telegram_chat_id, 'caption': caption}
        else:
            print("тЭМ Unsupported media format for Telegram.")
            return

        r = requests.post(url, files=files, data=data)
        print("ЁЯУд Telegram Status:", r.status_code)

    except Exception as e:
        print("тЭМ Telegram error:", e)

    finally:
        try:
            if os.path.exists(media_path):
                os.remove(media_path)
                print(f"ЁЯЧСя╕П Deleted: {media_path}")
        except Exception as e:
            print("тЪая╕П Could not delete media file:", e)


# === Fetch Random Quran Ayah ===
# Uses Al-Quran API (http://api.alquran.cloud) to fetch ayah in Bengali

def get_random_ayah():
    surah = random.choice(list(surah_ayah_counts.keys()))
    ayah_number = random.randint(1, surah_ayah_counts[surah])
    url = f"http://api.alquran.cloud/v1/ayah/{surah}:{ayah_number}/bn.bengali"
    try:
        res = requests.get(url)
        data = res.json()
        if data["status"] == "OK":
            return {
                "ayah": data["data"]["text"],
                "surah": bangla_surah_names.get(data["data"]["surah"]["number"]),
                "surah_id": data["data"]["surah"]["number"],
                "ayah_number": data["data"]["numberInSurah"],
                "surah_en": data["data"]["surah"]["englishName"],
                "surah_ar": data["data"]["surah"]["name"]
            }
    except Exception as e:
        print("Error fetching ayah:", e)
        return None
from bs4 import BeautifulSoup

import json
import os

USED_HADITH_FILE = "used_hadiths.json"

# Ensures no hadith is posted twice before the list resets

def get_random_hadith():
    total = len(all_hadiths)

    # Load used indexes
    if os.path.exists(USED_HADITH_FILE):
        with open(USED_HADITH_FILE, "r", encoding="utf-8") as f:
            used_indexes = json.load(f)
    else:
        used_indexes = []

    # Reset if all used
    if len(used_indexes) >= total:
        print("тЬЕ All hadiths used once. Resetting list...")
        used_indexes = []

    # Pick a new hadith not used yet
    while True:
        idx = random.randint(0, total - 1)
        if idx not in used_indexes:
            break

    used_indexes.append(idx)
    with open(USED_HADITH_FILE, "w", encoding="utf-8") as f:
        json.dump(used_indexes, f, ensure_ascii=False, indent=2)

    return all_hadiths[idx]

# === Image Generation ===
# Creates an image with footer text overlay for ayah/hadith

def create_quran_image(ayah_text, surah_name_en, ayah_number):
    try:
        bg_file = random.choice(os.listdir(QURAN_BG_DIR))
        img_path = os.path.join(QURAN_BG_DIR, bg_file)
        img = Image.open(img_path)
        draw = ImageDraw.Draw(img)

        font_footer = ImageFont.truetype(FONT_FOOTER, size=250)
        footer_text = f"{surah_name_en}, Ayah {ayah_number}"

        footer_w = draw.textlength(footer_text, font=font_footer)
        footer_x = (img.width - footer_w) // 2
        footer_y = (img.height - 450) // 2

        draw.text((footer_x, footer_y), footer_text, font=font_footer, fill="white")

        output_path = f"quran_ayah_{random.randint(1000,9999)}.jpg"
        img.save(output_path)
        return output_path
    except Exception as e:
        print("тЭМ Error generating image:", e)
        return None

def create_hadith_image(book, number, book_en):
    try:
        bg_file = random.choice(os.listdir(HADITH_BG_DIR))
        img_path = os.path.join(HADITH_BG_DIR, bg_file)
        img = Image.open(img_path)
        draw = ImageDraw.Draw(img)

        font_footer = ImageFont.truetype(FONT_FOOTER, size=200)
        footer_text = f"{book_en}, Hadith {number}"

        footer_w = draw.textlength(footer_text, font=font_footer)
        footer_x = (img.width - footer_w) // 2
        footer_y = (img.height - 450) // 2

        draw.text((footer_x, footer_y), footer_text, font=font_footer, fill="white")

        output_path = f"hadith{random.randint(1000,9999)}.jpg"
        img.save(output_path)
        return output_path
    except Exception as e:
        print("тЭМ Error generating image:", e)
        return None
# === Post to Facebook and Telegram ===
# Uploads media with published=false тЖТ gets media ID тЖТ posts with caption and auto comment тЖТ shares to Telegram

def post_quran_ayah(index):
    ayah = get_random_ayah()
    if not ayah:
        print("тЭМ Could not fetch ayah.")
        return

    image_path = create_quran_image(
        ayah_text=ayah["ayah"],
        surah_name_en=english_surah_names[ayah["surah_id"]],
        ayah_number=ayah["ayah_number"]
    )

    if not image_path or not os.path.exists(image_path):
        print("тЭМ Could not generate image.")
        return

    caption = f"""
тЬЕ Daily Quran Ayah:

'{ayah['ayah']}'

{ayah['surah']}, ржЖржпрж╝рж╛ржд {ayah['ayah_number']}

тЬЕ ржкрзНрж░рждрж┐ржжрж┐ржи ржХрзБрж░ржЖржирзЗрж░ ржЖрзЯрж╛ржд ржкрзЬрзБржиред
тЬЕ Like the page: рж╣рж┐ржжрж╛рзЯрж╛рж╣

#Quran #IslamicReminder #DailyAyah #рж╣рж┐ржжрж╛рзЯрж╛ржд  #IslamicQuotes #ржжрзАржи  #рждрж╛ржХржУржпрж╝рж╛ #hidayah
""".strip()

# === Upload image with published=false and capture media_id ===
    try:
        with open(image_path, "rb") as f:
            image_data = f.read()  # Read the file into memory

    #Step-1: Upload image with published=false

        upload_url = f"https://graph.facebook.com/v18.0/{PAGE_ID}/photos"
        files = {"source": ("quran.jpg", image_data)}
        upload_params = {
            "access_token": ACCESS_TOKEN,
            "published": "false"
        }
        upload_response = requests.post(upload_url, params=upload_params, files=files)
        upload_data = upload_response.json()
        media_id = upload_data.get("id")

        if not media_id:
            print("тЭМ Could not upload image.")
            return

    #Step-2: Now post to feed using attached_media

        post_url = f"https://graph.facebook.com/v18.0/{PAGE_ID}/feed"
        post_params = {
            "message": caption,
            "attached_media": json.dumps([{"media_fbid": media_id}]),
            "access_token": ACCESS_TOKEN
        }
        post_response = requests.post(post_url, data=post_params)
        response_data = post_response.json()
        print("ЁЯФБ Post response:", response_data)

    # Get post_id
        post_id = response_data.get("id") or response_data.get("post_id")
        if not post_id:
            print("тЭМ Could not get post ID to comment.")
            return

    #Step-3: Comment
        comment_text = "ЁЯдН ржЖржкржирж╛рж░ ржкрзНрж░рж┐рзЯ ржЖрзЯрж╛ржд ржХрзЛржиржЯрж┐? ржХржорзЗржирзНржЯрзЗ ржЬрж╛ржирж┐рзЯрзЗ ржжрж┐ржи! ЁЯУй\n#QuranDaily #IslamInspiration\n тЬЕ Join us:\nЁЯФ╗X (ex-twiiter): x.com/0019hidayah\nЁЯФ╗Telegram: https://t.me/hidayah019\nЁЯФ╗Intagram: instagram.com/0019hidayah\nЁЯФ╗Thread: thread.com/0019hidayah"
        comment_url = f"https://graph.facebook.com/v18.0/{post_id}/comments"
        comment_params = {
            "message": comment_text,
            "access_token": ACCESS_TOKEN
        }
        comment_response = requests.post(comment_url, data=comment_params)
        print("ЁЯТм Comment Status:", comment_response.status_code)
        print("ЁЯЧия╕П Comment Response:", comment_response.json())

    #Step-4: Share to Telegram тАФ now that everything is done
        share_to_telegram(caption, image_path, telegram_token, telegram_chat_id)

    #Step-5: Finally, delete the file 
        time.sleep(2)  # Small delay to ensure Telegram API is done with the file
        try:
            os.remove(image_path)
            print(f"ЁЯЧСя╕П Deleted image file: {image_path}")
        except Exception as e:
            print(f"тЪая╕П Could not delete media file: {e}")

    except Exception as e:
        print(f"тЭМ Facebook post/comment error:", e)

# === Post to Facebook and Telegram ===
# Uploads media with published=false тЖТ gets media ID тЖТ posts with caption and auto comment тЖТ shares to Telegram

def post_hadith(index):
    hadith = get_random_hadith()
    if not hadith:
        print("тЭМ Could not fetch hadith.")
        return

    image_path = create_hadith_image(hadith["book"], hadith["number"], hadith["book_en"])
    if not image_path or not os.path.exists(image_path):
        print("тЭМ Could not generate hadith image.")
        return

    caption = f"""
тЬЕ Daily Hadith
{hadith['text']}

ЁЯУЪ {hadith['book']}, рж╣рж╛ржжрж┐рж╕ {hadith['number']}

тЬЕ ржкрзНрж░рждрж┐ржжрж┐ржи ржПржХржЯрж┐ рж╣рж╛ржжрж┐рж╕ ржкрзЬрзБржиред
тЬЕ Like the page: Hidayah

#dailyHadith #Hadith #рж╣рж╛ржжрж┐рж╕ #ржжрзАржи #рж╣рж┐ржжрж╛рзЯрж╛рж╣
""".strip()

# === Upload image with published=false and capture media_id ===
    try:
        with open(image_path, "rb") as f:
            image_data = f.read()  # Read the file into memory

    #Step-1: Upload image with published=false
        upload_url = f"https://graph.facebook.com/v18.0/{PAGE_ID}/photos"
        files = {"source": ("quran.jpg", image_data)}
        upload_params = {
            "access_token": ACCESS_TOKEN,
            "published": "false"
        }
        upload_response = requests.post(upload_url, params=upload_params, files=files)
        upload_data = upload_response.json()
        media_id = upload_data.get("id")

        if not media_id:
            print("тЭМ Could not upload image.")
            return

    #Step-2: Now post to feed using attached_media
        post_url = f"https://graph.facebook.com/v18.0/{PAGE_ID}/feed"
        post_params = {
            "message": caption,
            "attached_media": json.dumps([{"media_fbid": media_id}]),
            "access_token": ACCESS_TOKEN
        }
        post_response = requests.post(post_url, data=post_params)
        response_data = post_response.json()
        print("ЁЯФБ Post response:", response_data)

    # Get post_id
        post_id = response_data.get("id") or response_data.get("post_id")
        if not post_id:
            print("тЭМ Could not get post ID to comment.")
            return

    #Step-3: Comment
        comment_text = "ЁЯд▓ ржЖрж▓рзНрж▓рж╛рж╣ ржЖржорж╛ржжрзЗрж░ рж╣рж╛ржжрзАрж╕ ржЕржирзБржпрж╛рзЯрзА ржЬрзАржмржи ржкрж░рж┐ржЪрж╛рж▓ржирж╛рж░ рждрж╛ржУржлрж┐ржХ ржжрж┐ржиред ржЖржорж┐ржиред \n#HadithDaily #IslamInspiration\n тЬЕ Join us:\nЁЯФ╗X (ex-twiiter): x.com/0019hidayah\nЁЯФ╗Telegram: https://t.me/hidayah019\nЁЯФ╗Intagram: instagram.com/0019hidayah\nЁЯФ╗Thread: thread.com/0019hidayah"
        comment_url = f"https://graph.facebook.com/v18.0/{post_id}/comments"
        comment_params = {
            "message": comment_text,
            "access_token": ACCESS_TOKEN
        }
        comment_response = requests.post(comment_url, data=comment_params)
        print("ЁЯТм Comment Status:", comment_response.status_code)
        print("ЁЯЧия╕П Comment Response:", comment_response.json())

    #Step-4: Share to Telegram тАФ now that everything is done
        share_to_telegram(caption, image_path, telegram_token, telegram_chat_id)

    #Step-5: Finally, delete the file
        time.sleep(2)  # Small delay to ensure Telegram API is done with the file
        try:
            os.remove(image_path)
            print(f"ЁЯЧСя╕П Deleted image file: {image_path}")
        except Exception as e:
            print(f"тЪая╕П Could not delete media file: {e}")

    except Exception as e:
        print(f"тЭМ Facebook post/comment error:", e)

# === Load Q&A Data and Posting ===
# Similar random-selection logic used for Q&A like hadith


QA_FILE = os.path.join(BASE_DIR, "data", "ifatwa_data_cleaned.json")
USED_QA_FILE = os.path.join(BASE_DIR, "data", "used_qa.json")

# Load QAs
with open(QA_FILE, "r", encoding="utf-8") as f:
    all_qas = json.load(f)

# Create tracker file if it doesn't exist
if not os.path.exists(USED_QA_FILE):
    with open(USED_QA_FILE, "w", encoding="utf-8") as f:
        json.dump([], f)

def get_random_qa():
    total = len(all_qas)
    used_indexes = []
    if os.path.exists(USED_QA_FILE):
        with open(USED_QA_FILE, "r", encoding="utf-8") as f:
            used_indexes = json.load(f)
    if len(used_indexes) >= total:
        print("тЬЕ All QAs used. Resetting list...")
        used_indexes = []

    while True:
        idx = random.randint(0, total - 1)
        if idx not in used_indexes:
            break

    used_indexes.append(idx)
    with open(USED_QA_FILE, "w", encoding="utf-8") as f:
        json.dump(used_indexes, f, ensure_ascii=False, indent=2)

    return all_qas[idx]

# === Post to Facebook and Telegram ===
# Uploads media with published=false тЖТ gets media ID тЖТ posts with caption and auto comment тЖТ shares to Telegram

def post_qa(index):
    qa = get_random_qa()
    if not qa:
        print("тЭМ Could not fetch QA.")
        return

    bg_file = random.choice(os.listdir(QA_BG_DIR))
    img_path = os.path.join(QA_BG_DIR, bg_file)

    if not os.path.exists(img_path):
        print("тЭМ Image not found:", img_path)
        return

    img = Image.open(img_path)

    caption = f"""
тЬЕ ржЬрж┐ржЬрзНржЮрж╛рж╕рж╛ ржУ ржЬржмрж╛ржм:

тЭУ ржкрзНрж░рж╢рзНржи: {qa['question']}

ЁЯУЭ ржЙрждрзНрждрж░: {qa['answer']}

тЬНя╕П {qa.get('author', 'ржЕржЬрж╛ржирж╛ рж▓рзЗржЦржХ')}

тЬЕ ржкрзНрж░рждрж┐ржжрж┐ржи ржирж┐рж░рзНржмрж╛ржЪрж┐ржд ржкрзНрж░рж╢рзНржирзЛрждрзНрждрж░ ржкрзЬрзБржи
тЬЕ Like the page: Hidayah

#ржжрзАржи #рж╣рж┐ржжрж╛рзЯрж╛рж╣ #ржЬрж┐ржЬрзНржЮрж╛рж╕рж╛ #ржЬржмрж╛ржм #ржЗрж╕рж▓рж╛ржорж┐_ржкрзНрж░рж╢рзНржи #hidayah
""".strip()

# === Upload image with published=false and capture media_id ===
    try:
        with open(img_path, "rb") as f:
            image_data = f.read()  # Read the file into memory

    #Step-1: Upload image with published=false
        upload_url = f"https://graph.facebook.com/v18.0/{PAGE_ID}/photos"
        files = {"source": ("quran.jpg", image_data)}
        upload_params = {
            "access_token": ACCESS_TOKEN,
            "published": "false"
        }
        upload_response = requests.post(upload_url, params=upload_params, files=files)
        upload_data = upload_response.json()
        media_id = upload_data.get("id")

        if not media_id:
            print("тЭМ Could not upload image.")
            return

    #Step-2: Now post to feed using attached_media
        post_url = f"https://graph.facebook.com/v18.0/{PAGE_ID}/feed"
        post_params = {
            "message": caption,
            "attached_media": json.dumps([{"media_fbid": media_id}]),
            "access_token": ACCESS_TOKEN
        }
        post_response = requests.post(post_url, data=post_params)
        response_data = post_response.json()
        print("ЁЯФБ Post response:", response_data)

    # Get post_id
        post_id = response_data.get("id") or response_data.get("post_id")
        if not post_id:
            print("тЭМ Could not get post ID to comment.")
            return

    #Step-3: Comment
        comment_text = "ЁЯЧия╕П ржЖржкржирж╛рж░ ржкрзНрж░рж╢рзНржи ржерж╛ржХрж▓рзЗ ржХржорзЗржирзНржЯрзЗ рж▓рж┐ржЦрзБржи ржмрж╛ ржЗржиржмржХрзНрж╕ ржХрж░рзБржиред \n#QADaily #IslamInspiration\n тЬЕ Join us:\nЁЯФ╗X (ex-twiiter): x.com/0019hidayah\nЁЯФ╗Telegram: https://t.me/hidayah019\nЁЯФ╗Intagram: instagram.com/0019hidayah\nЁЯФ╗Thread: thread.com/0019hidayah"
        comment_url = f"https://graph.facebook.com/v18.0/{post_id}/comments"
        comment_params = {
            "message": comment_text,
            "access_token": ACCESS_TOKEN
        }
        comment_response = requests.post(comment_url, data=comment_params)
        print("ЁЯТм Comment Status:", comment_response.status_code)
        print("ЁЯЧия╕П Comment Response:", comment_response.json())

    #Step-4: Share to Telegram тАФ now that everything is done
        share_to_telegram(caption, img_path, telegram_token, telegram_chat_id)

    #Step-5: Finally, delete the file 
        time.sleep(2)  # Small delay to ensure Telegram API is done with the file
        try:
            os.remove(img_path)
            print(f"ЁЯЧСя╕П Deleted image file: {img_path}")
        except Exception as e:
            print(f"тЪая╕П Could not delete media file: {e}")

    except Exception as e:
        print(f"тЭМ Facebook post/comment error:", e)

index = 1

while True:
    print(f"\nЁЯФБ Posting Index: {index}")
    try:
        if index % 3 == 1:
            print("тЭУ Posting QA")
            post_qa(index)
        elif index % 3 == 2:
            print("ЁЯУЬ Posting Hadith")
            post_hadith(index)
        else:
            print("ЁЯХЛ Posting Quran Ayah")
            post_quran_ayah(index)

    except Exception as e:
        print("Global Post Error:", e)

    index += 1
    time.sleep(3600)







